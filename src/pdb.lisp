(in-package :cl-pdb)

(defvar *records* (make-hash-table :test #'equalp))

(defun get-record-type (serial)
  (declare (type string serial))
  (gethash serial *records*))

(defun record-p (serial record)
  (declare (type string serial))
  (let ((record-type (get-record-type serial)))
    (if record-type (typep record record-type))))

(defgeneric read-as (type line args))
(defgeneric write-as (type args value))

(defmethod read-as ((type (eql 'string)) line args)
  (let ((start (1- (first args)))
        (end   (second args)))
    (modified-subseq line start end)))
(defmethod write-as ((type (eql 'string)) args value)
  (let ((length (1+ (- (second args) (first args)))))
    (if (null value)
      (format nil (format nil "~~~da" length) "")
      (format nil (format nil "~~~da" length) value))))

(defmethod read-as ((type (eql 'char)) line args)
  (let* ((n (first args))
         (str (read-as 'string line (list n n))))
    (if (plusp (length str))
      (char str 0))))
(defmethod write-as ((type (eql 'char)) args value)
  (if (null value)
    (format nil " ")
    (format nil "~c" value)))

(defmethod read-as ((type (eql 'integer)) line args)
  (parse-integer (read-as 'string line args) :junk-allowed t))
(defmethod write-as ((type (eql 'integer)) args value)
  (let ((length (1+ (- (second args) (first args)))))
    (if (null value)
      (format nil (format nil "~~~da" length) "")
      (format nil (format nil "~~~dd" length) value))))

(defmethod read-as ((type (eql 'float)) line args)
  (let* ((start (first args))
         (end   (second args))
         (power (third args))
         (point (- end power))
         (a (read-as 'integer line (list start (1- point))))
         (b (read-as 'integer line (list (1+ point) end))))
    (if (and a b)
      (+ a (* b (expt 10.0 (- power)))))))
(defmethod write-as ((type (eql 'float)) args value)
  (let ((length (1+ (- (second args) (first args)))))
    (if (null value)
      (format nil (format nil "~~~da" length) "")
      (format nil (format nil "~~~d,~df" length (third args)) value))))

(defun slot->defclass-slot (spec)
  (let ((name (first spec))
        (type (second spec)))
    `(,name :type ,type :initarg ,(as-keyword name) :accessor ,name)))

(defun slot->read-as (line spec)
  (let ((name (first spec))
        (type (second spec))
        (args (cddr spec)))
    `(setf ,name (read-as ',type ,line ',args))))

(defun slot->write-as (str record spec)
  (let* ((name (first spec))
         (type (second spec))
         (args (cddr spec))
         (start (1- (first args)))
         (end (second args)))
    `(setf (subseq ,str ,start ,end)
           (write-as ',type ',args (,name ,record)))))

(defun export-slot (spec)
  (let ((name (first spec)))
    `(export ',name)))

(defgeneric line->record (type line))
(defgeneric record->string (record))

(defmacro defrecord (name serial slots)
  (with-gensyms (typevar objectvar linevar stringvar recordvar)
    `(progn
      (defclass ,name ()
        ,(mapcar #'slot->defclass-slot slots))
      (defmethod line->record ((,typevar (eql ',name)) ,linevar)
        (let ((,objectvar (make-instance ',name)))
          (with-slots ,(mapcar #'first slots) ,objectvar
            ,@(mapcar (curry #'slot->read-as linevar) slots))
        ,objectvar))
      (defmethod record->string ((,recordvar ,name))
        (let ((,stringvar (format nil "~6a~74a" ,serial " ")))
          ,@(mapcar (curry #'slot->write-as stringvar recordvar) slots)
          (string-trim " " ,stringvar)))
      (export ',name)
      ,@(mapcar #'export-slot slots)
      (setf (gethash ,serial *records*) ',name))))

